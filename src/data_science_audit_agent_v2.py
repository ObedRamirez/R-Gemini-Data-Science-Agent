import re
import os
import sys
import argparse
from pathlib import Path
from typing import Union, Dict, List, Tuple, Optional
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.prompts import ChatPromptTemplate
from langchain.chains import LLMChain
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class RAuditResult(BaseModel):
    """Model for R code audit results"""
    corrected_code: str = Field(description="The corrected R code")
    errors_found: List[str] = Field(description="List of syntax errors found")
    improvements_made: List[str] = Field(description="List of improvements made")
    is_rmarkdown: bool = Field(description="Whether the input was RMarkdown format")
    severity_level: str = Field(description="Overall severity: low, medium, high")
    input_type: str = Field(description="Type of input: R Script, RMarkdown, or Markdown")

class RCodeAuditor:
    """
    Expert R Code Auditor Agent using LangChain with Google Gemini
    Corrects syntax errors and improves code quality in R scripts, RMarkdown, and Markdown files
    """
    
    def __init__(self, model_name: str = "gemini-2.5-flash", temperature: float = 0.1, google_api_key: Optional[str] = None):
        """
        Initialize the R Code Auditor with Gemini
        
        Args:
            model_name: Gemini model to use (gemini-2.5-flash, gemini-1.5-pro)
            temperature: Temperature for code generation (low for consistency)
            google_api_key: Google API key (if not set as environment variable)
        """
        # Set API key if provided
        if google_api_key:
            os.environ["GOOGLE_API_KEY"] = google_api_key
        
        # Check if API key is available
        if not os.getenv("GOOGLE_API_KEY"):
            raise ValueError(
                "Google API Key is required. Set GOOGLE_API_KEY environment variable "
                "or provide google_api_key parameter."
            )
        
        # Initialize Gemini model
        self.llm = ChatGoogleGenerativeAI(
            model=model_name,
            temperature=temperature,
            convert_system_message_to_human=True
        )
        self.output_parser = PydanticOutputParser(pydantic_object=RAuditResult)
        self._setup_prompts()
        
    def _setup_prompts(self):
        """Setup prompts for different audit scenarios"""
        
        # Main audit prompt for R scripts and general code
        self.audit_prompt = ChatPromptTemplate.from_messages([
            ("human", """You are an expert R programmer and code auditor. Your task is to identify and fix syntax errors in R code that was generated by AI agents or found in documentation. Focus on these common issues:

SYNTAX ERRORS TO FIX:
1. Missing parentheses, brackets, or braces
2. Incorrect operator usage (assignment operators, logical operators)
3. Malformed function calls and arguments
4. Incorrect string quoting and escaping
5. Missing commas in function arguments or data structures
6. Incorrect pipe operator usage (%>%, |>)
7. Malformed data.frame/tibble/list constructions
8. Incorrect library/package loading syntax
9. Missing semicolons where required
10. Incorrect variable naming (reserved words, invalid characters)

CODE QUALITY IMPROVEMENTS:
1. Add meaningful comments explaining complex operations
2. Ensure proper indentation and formatting
3. Add library loading statements if missing
4. Improve variable naming conventions
5. Add error handling where appropriate
6. Ensure reproducible code (set.seed for random operations)
7. Add data validation checks
8. Improve readability with spacing and line breaks

RULES:
- Preserve the original logic and functionality
- Only fix actual errors, don't change working code unnecessarily
- Add comments to explain complex or non-obvious operations
- Maintain R coding best practices
- Handle both plain R scripts and RMarkdown formats
- Ensure all required packages are loaded
- Make minimal changes while fixing maximum issues

Please audit and correct the following code:

INPUT TYPE: {input_type}
CODE:
```{language}
{code}
```

Analyze the code for syntax errors and quality issues, then provide the corrected version with explanations of what was fixed.

Return your response in the following JSON format:
{format_instructions}""")
        ])
        
        # RMarkdown/Markdown specific prompt
        self.markdown_prompt = ChatPromptTemplate.from_messages([
            ("human", """You are an expert in RMarkdown and Markdown documents containing R code. In addition to R syntax errors, also check for:

MARKDOWN/RMARKDOWN SPECIFIC ISSUES:
1. Malformed code chunk headers ```{{r}} or ```r
2. Missing chunk labels or options
3. Incorrect YAML header syntax
4. Improper chunk option syntax (echo, eval, include, etc.)
5. Missing or incorrect knitr options
6. Inline R code syntax errors `r `
7. Markdown formatting issues affecting R code blocks
8. Inconsistent code fence formatting
9. Missing language specifications in code blocks

MARKDOWN/RMARKDOWN BEST PRACTICES:
1. Add descriptive chunk labels
2. Set appropriate chunk options
3. Include setup chunk with common settings
4. Proper markdown headers and formatting
5. Clear separation between text and code
6. Consistent code block formatting
7. Proper language specification for syntax highlighting

Please audit and correct the following document:

INPUT TYPE: {input_type}
CODE:
```markdown
{code}
```

Fix syntax errors and improve the Markdown/RMarkdown structure while preserving content and formatting.

Return your response in the following JSON format:
{format_instructions}""")
        ])
        
    def _detect_input_type(self, code: str, file_extension: str = None) -> Tuple[str, str]:
        """
        Detect if input is plain R, RMarkdown, or Markdown with R code
        
        Args:
            code: The input code
            file_extension: File extension if available
            
        Returns:
            Tuple of (input_type, language_for_formatting)
        """
        # Check file extension first
        if file_extension:
            ext = file_extension.lower()
            if ext in ['.rmd', '.rmarkdown']:
                return "RMarkdown", "markdown"
            elif ext in ['.md', '.markdown']:
                return "Markdown", "markdown"
            elif ext in ['.r']:
                return "R Script", "r"
        
        # Check for RMarkdown/Markdown indicators in content
        rmd_patterns = [
            r'```\{r.*\}',  # R code chunks with options
            r'---\s*\n.*title:',  # YAML header
            r'`r\s+',  # Inline R code
        ]
        
        markdown_patterns = [
            r'```r\s*\n',  # R code blocks
            r'```R\s*\n',  # R code blocks (capital R)
            r'#{1,6}\s+',  # Markdown headers
            r'\*\*.*\*\*',  # Bold text
            r'\[.*\]\(.*\)',  # Links
        ]
        
        # Check for RMarkdown first (more specific)
        for pattern in rmd_patterns:
            if re.search(pattern, code, re.IGNORECASE | re.MULTILINE):
                return "RMarkdown", "markdown"
        
        # Check for Markdown with R code
        r_code_in_markdown = bool(re.search(r'```r\s*\n', code, re.IGNORECASE))
        has_markdown_elements = any(re.search(pattern, code, re.IGNORECASE | re.MULTILINE) 
                                  for pattern in markdown_patterns)
        
        if r_code_in_markdown or has_markdown_elements:
            return "Markdown", "markdown"
                
        return "R Script", "r"
    
    def _extract_r_code_blocks(self, content: str) -> List[Dict]:
        """Extract R code blocks from Markdown/RMarkdown for syntax checking"""
        # RMarkdown style chunks
        rmd_pattern = r'```\{r([^}]*)\}\n(.*?)```'
        rmd_matches = re.findall(rmd_pattern, content, re.DOTALL)
        
        # Standard markdown R code blocks
        md_pattern = r'```r\s*\n(.*?)```'
        md_matches = re.findall(md_pattern, content, re.DOTALL | re.IGNORECASE)
        
        code_blocks = []
        
        # Process RMarkdown chunks
        for i, (options, code) in enumerate(rmd_matches):
            code_blocks.append({
                'block_number': len(code_blocks) + 1,
                'type': 'rmarkdown_chunk',
                'options': options.strip(),
                'code': code.strip(),
                'start_line': content[:content.find(f'```{{r{options}}}')].count('\n') + 1
            })
        
        # Process standard markdown R code blocks
        for i, code in enumerate(md_matches):
            code_blocks.append({
                'block_number': len(code_blocks) + 1,
                'type': 'markdown_r_block',
                'options': '',
                'code': code.strip(),
                'start_line': content[:content.find(f'```r\n{code}')].count('\n') + 1
            })
            
        return code_blocks
    
    def _common_r_syntax_checks(self, code: str) -> List[str]:
        """
        Perform common R syntax checks
        Returns list of potential issues found
        """
        issues = []
        lines = code.split('\n')
        
        for i, line in enumerate(lines, 1):
            line_stripped = line.strip()
            if not line_stripped or line_stripped.startswith('#'):
                continue
                
            # Check for unmatched parentheses/brackets (simple check)
            parens = line.count('(') - line.count(')')
            brackets = line.count('[') - line.count(']')
            braces = line.count('{') - line.count('}')
            
            if parens > 1:  # Allow for single unmatched (multiline functions)
                issues.append(f"Line {i}: Possible unmatched parentheses")
            if brackets != 0:
                issues.append(f"Line {i}: Unmatched brackets")
            if braces != 0:
                issues.append(f"Line {i}: Unmatched braces")
                
            # Check for incorrect assignment operators
            if re.search(r'=\s*[^=]', line) and 'function' not in line and '==' not in line:
                if not re.search(r'^\s*\w+\s*=', line):  # Not a function argument
                    issues.append(f"Line {i}: Consider using '<-' instead of '=' for assignment")
                    
            # Check for missing commas in function calls
            if re.search(r'\w+\s*\([^)]*\w+\s+\w+[^)]*\)', line):
                issues.append(f"Line {i}: Possible missing comma in function arguments")
                
            # Check for incorrect pipe usage
            if '%>%' in line and not any(pkg in code for pkg in ['library(magrittr)', 'library(dplyr)', 'library(tidyverse)']):
                issues.append(f"Line {i}: Using %>% without loading required package")
                
        return issues
    
    def audit_code(self, code: str, file_extension: str = None) -> RAuditResult:
        """
        Main method to audit R code
        
        Args:
            code: R code, RMarkdown, or Markdown content to audit
            file_extension: File extension to help determine input type
            
        Returns:
            RAuditResult with corrected code and analysis
        """
        try:
            # Detect input type
            input_type, language = self._detect_input_type(code, file_extension)
            
            # Perform initial syntax checks on R code blocks
            initial_issues = []
            if input_type in ["Markdown", "RMarkdown"]:
                r_blocks = self._extract_r_code_blocks(code)
                for block in r_blocks:
                    block_issues = self._common_r_syntax_checks(block['code'])
                    initial_issues.extend([f"Block {block['block_number']}: {issue}" for issue in block_issues])
            else:
                initial_issues = self._common_r_syntax_checks(code)
            
            # Choose appropriate prompt based on input type
            if input_type in ["RMarkdown", "Markdown"]:
                chain = LLMChain(llm=self.llm, prompt=self.markdown_prompt)
                result = chain.run(
                    input_type=input_type,
                    code=code,
                    format_instructions=self.output_parser.get_format_instructions()
                )
            else:
                chain = LLMChain(llm=self.llm, prompt=self.audit_prompt)
                result = chain.run(
                    input_type=input_type,
                    language=language,
                    code=code,
                    format_instructions=self.output_parser.get_format_instructions()
                )
            
            # Parse the result
            try:
                audit_result = self.output_parser.parse(result)
            except Exception as parse_error:
                logger.warning(f"Failed to parse structured output: {parse_error}")
                # Fallback: create basic result
                audit_result = RAuditResult(
                    corrected_code=self._extract_code_from_response(result),
                    errors_found=initial_issues,
                    improvements_made=["Code formatting and structure improved"],
                    is_rmarkdown=(input_type == "RMarkdown"),
                    severity_level="medium",
                    input_type=input_type
                )
            
            # Set additional fields
            audit_result.is_rmarkdown = (input_type == "RMarkdown")
            audit_result.input_type = input_type
            
            # Add initial syntax issues to the result
            if initial_issues:
                existing_errors = set(audit_result.errors_found)
                for issue in initial_issues:
                    if issue not in existing_errors:
                        audit_result.errors_found.append(issue)
            
            # Determine severity level
            total_issues = len(audit_result.errors_found) + len(audit_result.improvements_made)
            if total_issues >= 10:
                audit_result.severity_level = "high"
            elif total_issues >= 5:
                audit_result.severity_level = "medium"
            else:
                audit_result.severity_level = "low"
                
            logger.info(f"Audit completed. Input: {input_type}, Severity: {audit_result.severity_level}, "
                       f"Errors: {len(audit_result.errors_found)}, "
                       f"Improvements: {len(audit_result.improvements_made)}")
            
            return audit_result
            
        except Exception as e:
            logger.error(f"Error during code audit: {str(e)}")
            # Return minimal result in case of error
            return RAuditResult(
                corrected_code=code,
                errors_found=[f"Audit error: {str(e)}"],
                improvements_made=[],
                is_rmarkdown=False,
                severity_level="unknown",
                input_type="unknown"
            )
    
    def _extract_code_from_response(self, response: str) -> str:
        """Extract code from response if JSON parsing fails"""
        # Try to find code blocks in the response
        code_patterns = [
            r'```markdown\n(.*?)```',
            r'```r\n(.*?)```',
            r'```R\n(.*?)```',
            r'```\n(.*?)```',
        ]
        
        for pattern in code_patterns:
            match = re.search(pattern, response, re.DOTALL)
            if match:
                return match.group(1).strip()
        
        # If no code blocks found, return the original response
        return response.strip()
    
    def quick_fix(self, code: str, file_extension: str = None) -> str:
        """
        Quick fix method that returns only the corrected code
        
        Args:
            code: Code to fix
            file_extension: File extension to help determine input type
            
        Returns:
            Corrected code as string
        """
        result = self.audit_code(code, file_extension)
        return result.corrected_code
    
    def audit_file(self, file_path: Union[str, Path]) -> RAuditResult:
        """
        Audit a file and return results
        
        Args:
            file_path: Path to the file to audit
            
        Returns:
            RAuditResult with corrected code and analysis
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                code = f.read()
            
            logger.info(f"Auditing file: {file_path}")
            return self.audit_code(code, file_path.suffix)
            
        except Exception as e:
            logger.error(f"Error reading file {file_path}: {str(e)}")
            raise
    
    def process_file(self, input_file: Union[str, Path], output_file: Optional[Union[str, Path]] = None) -> str:
        """
        Process a file and save the corrected version
        
        Args:
            input_file: Path to input file
            output_file: Path to output file (optional, will generate if not provided)
            
        Returns:
            Path to the output file
        """
        input_path = Path(input_file)
        
        # Generate output filename if not provided
        if output_file is None:
            if input_path.name.endswith('.md'):
                output_file = input_path.parent / f"revised_{input_path.name}"
            else:
                output_file = input_path.parent / f"revised_{input_path.stem}{input_path.suffix}"
        else:
            output_file = Path(output_file)
        
        # Audit the file
        result = self.audit_file(input_path)
        
        # Save corrected code
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(result.corrected_code)
        
        logger.info(f"Corrected code saved to: {output_file}")
        return str(output_file)

class GeminiModels:
    """Available Gemini models for different use cases"""
    
    @staticmethod
    def get_fast_auditor(api_key: Optional[str] = None) -> RCodeAuditor:
        """Get auditor with Gemini Flash (faster, less expensive)"""
        return RCodeAuditor(
            model_name="gemini-2.5-flash", 
            temperature=0.1,
            google_api_key=api_key
        )
    
    @staticmethod
    def get_pro_auditor(api_key: Optional[str] = None) -> RCodeAuditor:
        """Get auditor with Gemini Pro (more capable)"""
        return RCodeAuditor(
            model_name="gemini-1.5-pro",
            temperature=0.1,
            google_api_key=api_key
        )

def setup_api_key() -> str:
    """Helper to setup Gemini API key interactively"""
    api_key = input("Enter your Google API Key: ")
    os.environ["GOOGLE_API_KEY"] = api_key
    print("API key set successfully!")
    return api_key

def main():
    """Main function for command-line usage"""
    parser = argparse.ArgumentParser(description="R Code Auditor - Fix R code syntax and improve quality")
    parser.add_argument("input_file", help="Input file path (.R, .Rmd, .md)")
    parser.add_argument("-o", "--output", help="Output file path (optional)")
    parser.add_argument("--model", choices=["fast", "pro"], default="fast", 
                       help="Model to use: fast (gemini-2.5-flash) or pro (gemini-1.5-pro)")
    parser.add_argument("--api-key", help="Google API key (or set GOOGLE_API_KEY env var)")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose logging")
    parser.add_argument("--report", action="store_true", help="Generate detailed report")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        # Setup API key if provided
        if args.api_key:
            os.environ["GOOGLE_API_KEY"] = args.api_key
        elif not os.getenv("GOOGLE_API_KEY"):
            print("Google API Key required. Please provide via --api-key or GOOGLE_API_KEY environment variable")
            setup_api_key()
        
        # Initialize auditor
        if args.model == "fast":
            auditor = GeminiModels.get_fast_auditor()
        else:
            auditor = GeminiModels.get_pro_auditor()
        
        # Process file
        output_path = auditor.process_file(args.input_file, args.output)
        print(f"✅ File processed successfully!")
        print(f"📁 Output saved to: {output_path}")
        
        # Generate report if requested
        if args.report:
            result = auditor.audit_file(args.input_file)
            print(f"\n📊 Audit Report:")
            print(f"   Input Type: {result.input_type}")
            print(f"   Severity: {result.severity_level}")
            print(f"   Errors Found: {len(result.errors_found)}")
            print(f"   Improvements Made: {len(result.improvements_made)}")
            
            if result.errors_found:
                print(f"\n🔍 Errors Found:")
                for error in result.errors_found:
                    print(f"   - {error}")
            
            if result.improvements_made:
                print(f"\n✨ Improvements Made:")
                for improvement in result.improvements_made:
                    print(f"   - {improvement}")
    
    except KeyboardInterrupt:
        print("\n❌ Operation cancelled by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"❌ Error: {str(e)}")
        sys.exit(1)

# Module usage examples
def example_module_usage():
    """Example of how to use this as a module"""
    
    # Initialize auditor
    auditor = GeminiModels.get_fast_auditor()  # or provide API key
    
    # Process a single file
    output_path = auditor.process_file("script.Rmd")  # Will create "revised_script.Rmd"
    print(f"Output saved to: {output_path}")
    
    # Or audit code directly
    code = """
```r
library(dplyr
data <- read.csv("data.csv")
result <- data %>% 
    filter(age > 20 %>%
    summarize(mean_age = mean(age)
```
"""
    
    result = auditor.audit_code(code, file_extension=".Rmd")
    print("Corrected code:")
    print(result.corrected_code)

if __name__ == "__main__":
    main()